#문제
회사에 한 개의 회의실이 존재하고, N개의 회의에 대해서 일정표를 구성하려고 합니다.

각 회의 A에 대해 시작 시간과 종료시간이 주어져 있을 때, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보세요.

회의는 한번 시작하면 중간에 중단될 수 없다.
한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
첫째 줄에는 회의의 수 N이 주어지며, 둘째 줄 부터 N개의 회의에 대한 시작시간과 종료시간이 주어진다.





해설-----------------------
첫 시도에서의 생각은 각각 n과 alist=[[start,end],[start,end]. . . 반복]으로 값을 입력받았을 때

앞 리스트의 종료시간[i][1]<뒤 리스트의 시작시간[j][0] 인 모든 경우를 담는 리스트를 하나 더 생성하고 그 리스트의 길이가 가장 긴 값을 출력하는 방법
	-->반복문에서 꼬임 i와 j의 이중for문으로 인해 새 리스트에 계속 같은 리스트가 저장됨.

2 . 앞 리스트의 종료시간[i][1]<뒤 리스트의 시작시간[j][0] 인 모든 경우 중 각 반복문 별로 회의시간(종료시     간-시작시간)이 가장 짧은 값만 새 리스트에 저장하는 방법

	-->이것도 위와같이 계속 같은 값이 넣어지므로 가장 작은 리스트도 중복되게 넣어짐

3.(다른 사람 코드 참고) lambda와 sorted를 사용하는 방법

lambda로 리스트의 각각 시작시간,종료시간을 따로 표현해서 그 값들을 정렬 후 다른 회의시간들과 비교하는방법

lambda는 파이썬에서 한줄로 함수를 표현할 수 있게 해주는 형식인데 

lambda 매개변수 : 표현식 으로 활용할 수 있다.

예를들어

>>> def hap(x, y):
...   return x + y
...
>>> hap(10, 20)
30


이런 코드를

>>> (lambda x,y: x + y)(10, 20)
30


이런식으로 표현할 수 있다.



sorted함수는 값을 정렬해주는 함수인데 

sorted(정렬할 데이터, key=기준)과 같이 쓰인다.

예를들어 해당 문제에서

sorted(test,key=x[0])이라고하면 test라는 데이터(해당 문제에서는 리스트)에서 x[1]이 아닌 오직x[0]를 기준으로 데이터를 정렬하겠다는 의미이다.

코드로 나타내면 아래와 같다.

n=int(input())
time=[]
for i in range(n):
    start,end=map(int,input().split())
    time.append((start,end)) #()를 두번 감싸면 start와 end를 하나의 리스트로 test리스트에 넣을 수 있다.

time=sorted(time,key=lambda x:x[0]) #회의 시작시간 기준으로 정렬한 데이터를 다시 time에 저장
time=sorted(time,key=lambda x:x[1]) #회의 종료시간 기준으로 정렬한 데이터를 다시 time에 저장

count=0
last=0
for i,j in time:
    if i>=last:  #시작시간이 last인 종료시간보다 크면 count
        count+=1 #정렬된 상태니까 회의시간을 따로 생각할 필요 없이 count만 높이면 됨
        last=j  #종료시간을 last에 저장
        
print(count)




 if i>=last:  
        count+=1 
        last=j  


이부분에서 i와 j를 직접비교하지 않고 굳이 last라는 변수를 쓰는 이유는 i>=j이면 다음 회의를 고려하지 않고 단순하게 시작시간이 더 느린 데이터만 찾게 되기때문이다.

그래서 last라는 변수를 넣어 각각 정렬된 시간 데이터에서 첫번째로 시작시간보다 작은 종료시간을 찾은 후 
그 값을 last에 저장하여 다음 종료시간보다 큰(늦게 시작하는) 시작시간을 찾아야한다.
